# -*- coding: utf-8 -*-
"""evaluation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gxE2D9gCo-5o6xnkSrMEjdjuSCDe8gSu
"""

import numpy as np
import os
import argparse
import time
import librosa
import pickle
from tqdm import tqdm
import torch
import re
import torch.nn as nn
import torch.nn.functional as F
import torch.nn.utils.spectral_norm as spectral_norm
import IPython.display as display
import gc
from torch.utils.data.dataset import Dataset
import math

from scipy.io import wavfile
#import pyworld as pw
import os
import numpy as np
import librosa
import matplotlib.pyplot as plt
import librosa.display
import IPython.display as ipd
from os import walk
import IPython.display as display
import torch
from scipy.signal import get_window
import librosa.util as librosa_util
import torch.nn.functional as F
from torch.autograd import Variable
from scipy.signal import get_window
from librosa.util import pad_center, tiny
from librosa.filters import mel as librosa_mel_fn # Create a Filterbank matrix to combine FFT bins into Mel-frequency bins
import glob
import tqdm
import random
import subprocess
from scipy.io.wavfile import read
import yaml
from torch.utils.data.dataset import Dataset
import pickle

import argparse

from tqdm import tqdm
from os.path import exists, dirname, basename, join
from scipy.fftpack import fft

import statistics

#! pip install pyworld
#! pip install soundfile

#35-dimensional mel-cepstrum parameters were extracted from the target or converted waveform using WORLD
n_mel_channels= 80
segment_length= 16000
pad_short= 2000
filter_length= 1024
hop_length= 256 # WARNING: this can't be changed.
win_length= 1024
sampling_rate= 22050
mel_fmin= 0.0
mel_fmax= 8000.0
n_mfcc = 35

path="/content/drive/MyDrive/My_CycleGAN"
os.chdir(path)

import soundfile as sf
import pyworld as pw
from shutil import rmtree



def savefig(filename, figlist, log=True):
    #h = 10
    EPSILON = 1e-8
    n = len(figlist)
    # peek into instances
    f = figlist[0]
    if len(f.shape) == 1:
        plt.figure()
        for i, f in enumerate(figlist):
            plt.subplot(n, 1, i+1)
            if len(f.shape) == 1:
                plt.plot(f)
                plt.xlim([0, len(f)])
    elif len(f.shape) == 2:
        Nsmp, dim = figlist[0].shape
        #figsize=(h * float(Nsmp) / dim, len(figlist) * h)
        #plt.figure(figsize=figsize)
        plt.figure()
        for i, f in enumerate(figlist):
            plt.subplot(n, 1, i+1)
            if log:
                x = np.log(f + EPSILON)
            else:
                x = f + EPSILON
            plt.imshow(x.T, origin='lower', interpolation='none', aspect='auto', extent=(0, x.shape[0], 0, x.shape[1]))
    else:
        raise ValueError('Input dimension must < 3.')
    plt.savefig(filename)

def wav2coded_sp(wav_file):
    # load wav
    x, fs = sf.read(wav_file)

    # 2-3 Harvest with F0 refinement (using Stonemask)
    _f0_h, t_h = pw.harvest(x, fs)
    f0_h = pw.stonemask(x, _f0_h, t_h, fs)
    sp_h = pw.cheaptrick(x, f0_h, t_h, fs) # Harmonic spectral envelope
    ap_h = pw.d4c(x, f0_h, t_h, fs)

    # Get Mel-cepstral coefficients (MCEPs)
    coded_sp = pw.code_spectral_envelope(sp_h, fs, 35)

    return coded_sp, f0_h, ap_h, x


# modulation spectra distance (MSD) = root mean square error between the target and converted logarithmic modulation 
# spectra of MCEPs 
# averaged over all MCEP dimensions and modulation frequencies
def msd(cvt, trg):
    #print(fft(cvt.T).max(), fft(cvt).T.max()) # (1916.5970984190676-0j) (-1.6122297271751669+0.515492935126461j)
    
    cvt_ms = np.log(np.abs(fft(cvt.T, n = 80)))  #fft(cvt.T, n = 64)
    trg_ms = np.log(np.abs(fft(trg.T, n = 80)))  # (35,583) (35,476) 

    minT = min(cvt.shape[1], trg.shape[1])
    msd = np.sqrt(np.mean((cvt_ms[:, :minT] - trg_ms[:, :minT])**2))
    return msd

# Mel-cepstral distortion (MCD) = distance between the target and converted MCEP sequences
def mcd(cvt, trg):
    #print('D=35', cvt.shape[1])
    minT = min(cvt.shape[0], trg.shape[0])
    alpha = (10 * np.sqrt(2)) / np.log(10) 
    return alpha * np.mean(np.sqrt(np.sum((trg[:minT, 1:] - cvt[:minT, 1:]) ** 2, axis=1))) # 先D，后T




if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="generate training dataset and stats")

    source_path = './vcc2020_database_training_source/source/SEM1/'
    target_path = './vcc2020_database_training_target_task1/target_task1/TEM2/'

    true_A_dir = source_path
    output_B_dir = './vcc2020_database_evaluation/vcc2020_database_evaluation/B2A_M2toM1'

    true_B_dir = target_path
    output_A_dir = './vcc2020_database_evaluation/vcc2020_database_evaluation/A2B_M1toM2'

    parser.add_argument('--true_A_dir', type=str,
                        help="real A", default=true_A_dir)
    parser.add_argument('--output_B_dir', type=str,
                        help="converted A from B", default=output_B_dir)
    parser.add_argument('--true_B_dir', type=str,
                        help="real B", default=true_B_dir)
    parser.add_argument('--output_A_dir', type=str,
                        help="converted B from A", default=output_A_dir)
    
        
    argv, unknown = parser.parse_known_args()

    true_A_dir = argv.true_A_dir
    output_B_dir = argv.output_B_dir
    true_B_dir = argv.true_B_dir
    output_A_dir = argv.output_A_dir


    # Comparison
    if os.path.isdir('./test'):
      rmtree('./test')
    os.mkdir('./test')

    mcd_value_sum = []
    msd_value_sum = []

    nb = len(os.listdir(output_A_dir))
    l_true_path = os.listdir(true_B_dir)
    for i, file in enumerate(os.listdir(output_A_dir)):
      AoutBPath = os.path.join(output_A_dir, file) 
      if os.path.exists(os.path.join(true_B_dir, file)):
        BtarPath = os.path.join(true_B_dir, file)
      else:
        BtarPath = os.path.join(true_B_dir, l_true_path[i])  
      
      AoutB, f0_ho, ap_ho, xo = wav2coded_sp(AoutBPath)
      Btar, f0_ht, ap_ht, xt = wav2coded_sp(BtarPath)

      Asoui, f0_hi, ap_hi, xi = wav2coded_sp(os.path.join(true_A_dir, file)) 

      # Comparison

      print(file[:-4])
      savefig('./test/A2Bwavform'+file[:-4]+'.png', [xi, xo, xt])
      savefig('./test/A2Bsp'+file[:-4]+'.png', [Asoui, AoutB, Btar])
      savefig('./test/A2Bap'+file[:-4]+'.png', [ap_hi, ap_ho, ap_ht], log=False)
      savefig('./test/A2Bf0'+file[:-4]+'.png', [f0_hi, f0_ho, f0_ht])

      
      mcd_value = mcd(AoutB, Btar)
      msd_value = msd(AoutB, Btar)
      #print(mcd_value, msd_value)

      mcd_value_sum.append(mcd_value)
      msd_value_sum.append(msd_value)

    mcd_value_mean = sum(mcd_value_sum) / nb
    msd_value_mean = sum(msd_value_sum) / nb 

    mcd_value_std = statistics.stdev(mcd_value_sum)
    msd_value_std = statistics.stdev(msd_value_sum)

    print(mcd_value_mean, msd_value_mean, mcd_value_std, msd_value_std)

    fig, axs = plt.subplots(1,2, sharey=True, tight_layout=True)

    bins2 = np.linspace(math.ceil(min(mcd_value_sum)), 
                      math.floor(max(mcd_value_sum)),
                      20) # fixed number of bins

    axs[0].set_xlim([min(mcd_value_sum)-0.2, max(mcd_value_sum)+0.2])

    axs[0].hist(mcd_value_sum, bins=bins2, alpha=0.5)
    axs[0].set_title('mcd distribution')
    axs[0].set_xlabel('mcd')
    axs[0].set_ylabel('count')

    bins = np.linspace(min(msd_value_sum), 
              max(msd_value_sum),
              20) # fixed number of bins
    print(min(msd_value_sum), max(msd_value_sum))
    axs[1].set_xlim([min(msd_value_sum)-0.01, max(msd_value_sum)+0.01])
    axs[1].hist(msd_value_sum, bins=bins, alpha=0.5)
    axs[1].set_title('msd distribution')
    axs[1].set_xlabel('msd')
    axs[1].set_ylabel('count')

    fig.suptitle('A to B', fontsize=16)


    fig.show()
    ##################################################################################
    mcd_value_sum = []
    msd_value_sum = []

    nb = len(os.listdir(output_B_dir))
    l_true_path = os.listdir(true_A_dir)

    for i, file in enumerate(os.listdir(output_B_dir)):
      BoutAPath = os.path.join(output_B_dir, file) 

      if os.path.exists(os.path.join(true_A_dir, file)):
        AtarPath = os.path.join(true_A_dir, file)
      else:
        AtarPath = os.path.join(true_A_dir, l_true_path[i])  
      
      BoutA, f0_ho, ap_ho, xo = wav2coded_sp(BoutAPath)
      Atar, f0_ht, ap_ht, xt = wav2coded_sp(AtarPath)

      Bsoui, f0_hi, ap_hi, xi = wav2coded_sp(os.path.join(true_B_dir, file)) 

      print(file[:-4])
      savefig('./test/B2Awavform_'+file[:-4]+'.png', [xi, xo, xt])
      savefig('./test/B2Asp_'+file[:-4]+'.png', [Bsoui, BoutA, Atar])
      savefig('./test/B2Aap_'+file[:-4]+'.png', [ap_hi, ap_ho, ap_ht], log=False)
      savefig('./test/B2Af0_'+file[:-4]+'.png', [f0_hi, f0_ho, f0_ht])

      
      mcd_value = mcd(BoutA, Atar)
      msd_value = msd(BoutA, Atar)
      #print(mcd_value, msd_value)

      mcd_value_sum.append(mcd_value)
      msd_value_sum.append(msd_value)

    mcd_value_mean = sum(mcd_value_sum) / nb
    msd_value_mean = sum(msd_value_sum) / nb 

    mcd_value_std = statistics.stdev(mcd_value_sum)
    msd_value_std = statistics.stdev(msd_value_sum)

    print(mcd_value_mean, msd_value_mean, mcd_value_std, msd_value_std)
    fig, axs = plt.subplots(1,2, sharey=True, tight_layout=True)

    bins2 = np.linspace(math.ceil(min(mcd_value_sum)), 
                      math.floor(max(mcd_value_sum)),
                      20) # fixed number of bins

    axs[0].set_xlim([min(mcd_value_sum)-0.2, max(mcd_value_sum)+0.2])

    axs[0].hist(mcd_value_sum, bins=bins2, alpha=0.5)
    axs[0].set_title('mcd distribution')
    axs[0].set_xlabel('mcd')
    axs[0].set_ylabel('count')

    bins = np.linspace(min(msd_value_sum), 
              max(msd_value_sum),
              20) # fixed number of bins
    print(min(msd_value_sum), max(msd_value_sum))
    axs[1].set_xlim([min(msd_value_sum)-0.01, max(msd_value_sum)+0.01])
    axs[1].hist(msd_value_sum, bins=bins, alpha=0.5)
    axs[1].set_title('msd distribution')
    axs[1].set_xlabel('msd')
    axs[1].set_ylabel('count')

    fig.suptitle('B to A', fontsize=16)


    fig.show()
